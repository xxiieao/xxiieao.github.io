---
layout: post
title:  "Genetic Algorithm"
date: 2014-10-19 14:30:00
categories: "algorithm"
author: xxiieao
---

遗传算法是计算科学中和生物最为紧密的算法。从用途上来说，这个算法常常被用来求最优解，和机器学习有着某些异曲同工的地方。不过这个算法最迷人的地方是它里面的数据是“活”的。

让我们先来回想一下大自然中生物是怎样进化的——有一小群生物，它们努力地从周边环境中摄取营养，在性成熟之后便通过交配或者自体分裂等行为繁殖下一代。而较弱的个体由于先天上的差距，在环境压力下会导致无法顺利繁殖下一代，于是群体中强壮的个体则越来越多。同时遗传物质在复制中的不稳定性则会导致下一代个体相对于母体总有一些变化，环境压力会同样把这些变异的个体中优秀的部分筛选出来。

遗传算法也是这么做的：我们以随机生成的数据作为“生物”，设置一定的表达式作为“环境压力”，根据压力筛选“生物”。而这些数据还可以通过复制自己来产生下一代数据。具体来说遗传算法的过程如下：

- 初始化。这一步需要决定群体大小P，并且随机生成P个个体“数据”。为了方便这里举个简单的例子：设P=5，然后我们得到了一个个体分别为1，2，3，4，5的群体。当然实际运算时，P往往为1000～10000。

- 个体评价。这一步需要决定如何计算个体的表现（术语叫适应度）。同样我们假设以函数f（x）=abs（x-8）来计算。易知前面五个个体的适应度分别为7，6，5，4，3。一般情况下适应度越高越好，不过上面这个例子中我们目标是筛选出离8最近的数字，因此是越低越好。

- 个体选择。这一步需要决定“环境压力”，即数据的筛选方式。有好几种方法：绝对阈值筛选，末位淘汰和随机淘汰。其中绝对阈值和末位淘汰好理解，随机淘汰，是按照个体表现，表现好的淘汰概率低，表现差的淘汰概率高。从原理上来说随机淘汰更符合实际自然，这种筛选法回避局部最优值的能力更强，但是搜索最优值效率也更低。在我们的例子中，为了简要说明就使用最简单的末尾淘汰制，淘汰个体1和2，剩下3，4，5。

- 繁殖。这一步常常被拆成两步运算交叉运算和变异运算。实际上是模仿生物繁殖时，染色体交叉和基因位点突变的行为。

  如何对数据进行交叉和变异运算，涉及到数据编码问题，这本身也是一个较大的话题，因此这里我们也按照传统的遗传算法用最简单的方式处理一下。首先将剩下的3，4，5三个个体转化成二进制编码。

  3 => 00011

  4 => 00100

  5 => 00101

  假设随机抽到3和5进行交换，**.**是随机决定的交换位点

  3 => 000.11

  5 => 001.01

  交换后的新个体：

  00001

  00111

  突变则是指例如3 => 00011的一个编码突变成为10011。

  交换和突变的设置是决定遗传算法性能最关键的地方，总的来说交换发生概率应该比突变概率高一个数量级，前者为40～90%，后者为1～10%。因为交换是比突变更可靠的变异来源，但是二者也不宜太高，因为过于频繁的变化会使新进化出来的好个体过快的流失。除了交换和突变产生的新个体之外，新的一代中应当还有大量由上一个群体复制而保留下来的个体。例如在我们的例子中，经历了繁殖后新一代群体中组成可能是

  3 => 00011

  4 => 00100

  5 => 00101

  New=>00001

  New=>00111

- 循环2-4步，并设置一个终止条件。例如1000代后停止，并输出群体中最优秀的个体。

从上面可以看到，在遗传算法中，你的数据如同一个活的生物一样，对抗环境，繁殖自后代，通过交换“基因”（编码）以及突变逐渐“进化”。