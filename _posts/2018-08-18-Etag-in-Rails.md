---
layout: post
title:  "Etag in Rails"
date: 2018-08-18 16:08:40 +1200
categories: "ruby-on-rails"
author: xxiieao
toc: true
---

# What is ETag

An ETag (entity tag) is a token representing a specific version of a network resource. Transfering data via network is expensive and time-consuming. One effective solution is passing "fingerprints" between clients and servers. When a client sends a request to a server for the first time, the client would receive not only some contents but also an ETag as the "fingerprint" of the response content. If the client requests the same resource again, it should include this ETag in HTTP header, and it is so called **conditional get**. The server would compare the client's ETag and the current server's ETag, if the ETag is the same which means the content has not changed, the server will only return a status code 304 (not modified) rather than a full response. In this way, clients could use the local cache more efficiently.

For a quick comparison, ETags should be concise and unique, so hash functions are the most common methods to generate ETags.

# Strong and Weak ETags

There are two types of ETags, strong and weak. Weak ETag has a "W/" prefix.

> W/"abc"

On wikipedia's HTTP_ETag page, I found the following words:

> A strongly validating ETag match indicates that the content of the two resource representations is byte-for-byte identical

> A weakly validating ETag match only indicates that the two representations are semantically equivalent

What is semantically equivalent? Wikipedia has a page for **semantically equivalent**, and it gave an example.


```bash
<DataElement>
    <Name>PersonFamilyName</Name>
    <Definition>The name of a person shared with other members of their family.</Definition>
<DataElement>

<DataElement>
    <Name>IndividualLastName</Name>
    <Definition>The name of an individual person shared with other members of their family.</Definition>
<DataElement>

```

It was really confusing. I don't think those contents can generate the same Etag. When I search "Strong and Weak ETag" for help, most pages only tell me the following table

|ETag 1  |ETag 2  |Strong Comparison   |Weak Comparison|
|:------:|:------:|:------------------:|:-------------:|
|W/"1"   |W/"1"   |no match            |match          |
|W/"1"   |W/"2"   |no match            |no match       |
|W/"1"   |"1"     |no match            |match          |
|"1"     |"1"     |match               |match          |

Ok, it is a useful message but doesn't solve my problem. Finally, I found the right [answer](https://stackoverflow.com/questions/25443467/how-are-weak-etags-implemented) on stackoverflow

> A web resource would return the same ETag if an underlying model does not change, regardless of the representation used. For example you have an endpoint displaying product information in HTML4, HTML5, plan XML and JSON - same weak ETag should be returned if the product's model does not change.


# How to implement ETags in a rails project

Rails has a built-in conditional get support mechanism. The following code from [rails guide](https://guides.rubyonrails.org/caching_with_rails.html) shows the simplest way to implement etags in a rails project.


```ruby
  def show
    @product = Product.find(params[:id])
    fresh_when last_modified: @product.published_at.utc, etag: @product
  end

```

By default, Rails 5 generates weak ETags, which are different from Rails 4. If you want to generate strong Etag, you can do it by alternating the keyword to "strong_etag". 


```ruby
  def show
    @product = Product.find(params[:id])
    fresh_when last_modified: @product.published_at.utc, strong_etag: @product
  end

```

You can also use **etag {}** to add additional validators for ETag generating.

```ruby
class ProductsController < ApplicationController
  etag { current_user.id }

  def show
    @product = Product.find(params[:id])
    fresh_when last_modified: @product.published_at.utc, strong_etag: @product
  end
end

```

It allows you add the current user id as an extra validator, which can avoid displaying of unauthorized cached pages.

# How dose rails generate ETags

There are two steps to generate ETags
- Collecting and combining all the validators
- Using hexdigest function to convert combined validators into a hash string

Two critical methods are involved in this process flow, one is the private method **:combine_etags** of the controller itself, the other is the private method **:generate_strong_etag**. Notice that all etags are generated by **:generate_strong_etag**, if you check the source code you would find that the method **:generate_weak_etag** is only a wrap of **:generate_strong_etag**.


```ruby
def generate_weak_etag(validators)
  "W/#{generate_strong_etag(validators)}"
end

def generate_strong_etag(validators)
  %("#{ActiveSupport::Digest.hexdigest(ActiveSupport::Cache.expand_cache_key(validators))}")
end

```

We can repeat the ETag generation process in a controller instance as following


```ruby
class ProductsController < ApplicationController
  etag { current_user.id }

  def show
    @product = Product.find(params[:id])
    conbimd_validators = self.send :combine_etags, @product, {last_modified: @product.published_at.utc}
    puts response.send :generate_weak_etag, conbimd_validators
    fresh_when last_modified: @product.published_at.utc, etag: @product
  end
end
``` 

Now we can compare the etag received by the browser to the one printed on server log, and they are the same.