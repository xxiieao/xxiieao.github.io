---
layout: post
title:  "RSA and Pseudo-random number"
date: 2016-01-30 12:01:17
categories: "algorithm"
author: xxiieao
---

关于随机数的生成，一般而言大部分计算机语言都有一个随机函数，通常是一个能生成一个0～1之间随机数的函数。但是如果我要一次生成1亿个不重复的随机数，使用内置函数并不是特别好的方法。一个有意思的解决方案就是使用RSA算法来高效生成伪随机。在了解这个方法之前，先来简单了解一下RSA算法的运作原理。

RSA是相当著名的加密算法，巧妙地利用了欧拉定理和难以进行大质数分解的特性，具有非常高的保密性。所谓欧拉定理就是指，如果两个正整数a和b互质(即不存在1以外的公因数),那么以下公式成立

$$a^{\varphi(b)}\mathbf{mod}\ b \equiv 1$$

其中$$\varphi(b)$$表示求b的欧拉数，欧拉数的意思是比b小的正整数中与其互质数字的数量。例如求$$\varphi(10)$$，比10小的数字有1～9，而1，3，7，9与10互质，那么$$\varphi(10) = 4$$。

给上面的欧拉公式代入两个具体的质数$$a=13$$和$$b=7$$，可知

$$13^{\varphi(7)}\mathbf{mod}\ 7=1$$

了解RSA算法之前还需要了解一个概念————**模反元素**，a和b互质，则必然存在整数c，使得$$a*c-1$$可以整除b。c就是a的模反元素。

RSA的过程是这样的，首先挑选两个不相等质数，例如3和11，将其相乘得到33，然后求解$$\varphi(33)$$，这里需要补充说明，假设b是两个质数$$(b_1,b_2)$$的乘积，那么以下公式成立

$$\varphi(b) = (b_1 - 1)*(b_2 - 1)$$

然后计算$$\varphi(3*11)$$时我们便可以知道答案是20。接下来在1～20之间挑一个与20互质的数，我们随机选择质数17。最后求出17与20的模反元素e，即$$(17*e)\ \mathbf{mod}\ 20 = 1$$。易知，e可以取13，这里我们就选13。总结以下我们获得的重要数据有33 20 17 13，其中33与17是公钥，而33和13是私钥匙。

现在我们可以对33以下的数字进行加密了，例如数字25，使用公钥进行计算$$25^{17}\mathbf{mod}\ 33=31$$，拿到的加密过的信息是31

然后使用私钥解密，进行计算$$31^{13}\mathbf{mod}\ 33=25$$，就能拿回原来的数字了。

在这个加密解密的过程中，有个重要的一点是加密前数值的与加密后的数值是一一对应的。因为如果有两个数字通过加密之后是同样的密文，解密的时候也会得到同样的数字，因此不同的数字不可能得到同样的密文。而不重复伪随机数的生成也可以利用这一点。继续上文的例子，通过加密1：32这个数列，我们实际上得到了如下伪随机数列。

 1 29  9 16 14 30 28  2 15 10 11 12  7 20 27 25  8  6 13 26 21 22 23 18 31 5  3 19 17 24  45  3 19 17 24  4

 如果需要更改顺序只需要更换公钥就可以了。更方便的是，因为生成伪随机数列不需要再解密，因此不需要寻找模反元素，只需要挑互质元素就可以了，因此上文中除了使用（33，17）加密以外，17还可以更换成3、7、9、11、13、19这六个值（与20互质即可）。
