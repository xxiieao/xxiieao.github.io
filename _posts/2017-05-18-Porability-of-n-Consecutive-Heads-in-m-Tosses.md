---
layout: post
title:  "Porability of n Consecutive Heads in m Tosses"
date: 2017-05-18 22:05:34 +0800
categories: "math"
author: xxiieao
---

最近玩游戏碰到这样一种情况——玩家进行某随机事件时会以各1/2的概率得到A和B两种结果，如果玩家以B目标反复进行该事件时，却往往会连续获得好几次A的结果。无疑这种结果通常会使玩家大为恼火，因为根据常识来说连续获得n次A的概率是$$0.5^n$$，例如当n为5的时候，这个值仅为0.03125，一般而言到这种时候玩家该破口大骂游戏的随机函数了。不过连续出现真的是一个小概率事件吗？为了回答这个问题，我们将前面描述的问题更一般化一点——“在m次硬币投掷中，出现连续n及以上次正面的概率是多少？”

关于这个问题有三种解法:

### 枚举

第一种最为传统，就是枚举所有符合条件的情况，然后除以$$2^n$$。有一种想法认为把n次连续正面看作一个事件，然后取全排列就是有$$(m-n+1)*2^{m-n}$$。这个想法显然是错误的，原因很简单很多情况被重复计算了，例如m次连续正面这个种情况在这种方法下就被计算了m-n+1次。那么正确的枚举方法应该怎么做呢？为了叙述方便，也防止被符号绕晕，先设n=4,m=10。

首先考虑第4次就完成4次连续正面的情况，共有$$2^6$$种。

然后考虑第5次才完成4次连续正面的情况，也就是意味着前5次的顺序必须是——反正正正正，共有$$2^5$$种。

接下来考虑第6次才完成的情况，第2至6次的顺序必须是——反正正正正，第一次和后面则可以随意，也一共有$$2^5$$种。

这样下来一直到了第9次才完成的情况的时候则有所不同了，第5至9次必须是——反正正正正，但是前4次则不是任意的。前4次必须排除掉连续四次正面这种情况，所以总数是$$(2^4-1)*2$$。

这个解不仅复杂，而且非常容易出错，m和n的值一大还非常难算。

### 斐波那契数列

第二种稍微有点赖皮，它直接利用了一个结论——“在m次硬币投掷中，不出现连续n及以上次正面的次数为$$F^{n}_{m+2}$$”。$$F^{n}_{m+2}$$是n阶的斐波那契数列（n-step Fibonacci sequence）。平常我们说的斐波那契数列，实际上主要指的是n为2的情况，也就是说每一个数都等于前两个数之和。即

$$
F_n =
\begin{cases}
0, & \text{n = 0} \\
1, & \text{n = 1} \\
F(n-1) + F(n-2), & \text{n > 1} \\
\end{cases}
$$

当然斐波那契数列是有通项公式的，形式如下

$$
F_n = \frac{\left (\frac{1 + \sqrt{5}}{2} \right )^{n} - \left (\frac{1 - \sqrt{5}}{2} \right )^{n}}{\sqrt{5}}
$$

这个通项公式相当有意思，它的结果都是整数，但是公式里却有大量的无理数。不过这个内容不是文章的重点，不继续展开了。所谓n步的斐波那契数列，其实稍微修改一下条件，每一个数都等于前n个数之和。当然这个的通项公式也是有的，不过就很复杂了，如果m和n不是很大的情况下用迭代法计算也是一个不错的选择。

### 马尔可夫链

第三种方法是我最喜欢的一种方法——马尔可夫链，解法也非常优美。对于不熟悉马尔可夫链的人，首先需要明确在每一次硬币投掷之前，我们会一定会处于某种状态，比如已经有三次连续正面了。如果投掷m次，可以知道状态就一共会有m+1种，下面我们要做的就是建立一个$$(m+1) \times (m+1)$$转移矩阵M来描述这m+1种状态之间相互转换的概率。

$$
\begin{pmatrix}
     1/2     &   1/2 &      0 & \cdots &      0   \\
     1/2     &     0 &    1/2 & \cdots &      0   \\
     \vdots  & \vdots& \vdots & \ddots & \vdots   \\
     1/2     &     0 &      0 & \cdots &      1/2 \\   
     0       &     0 &      0 & \cdots &      1    
\end{pmatrix}
$$

简单解释一下这个转移矩阵M，第一行表示当你处于状态0,也就是还没有获得过正面的情况下，你有1/2的概率留在状态0,也有1/2概率进入状态1（即获得一个正面）。同样可以理解第二行，当你处于状态1的时候，你有1/2概率回到状态0,也有1/2概率进入状态2（即连续2个正面）。最后一行，表示当你进入状态m时，你就永远留在这个状态了（因为投掷已经结束了）。

要利用这个矩阵非常简单，我们只需要用一个$$(m+1) \times 1$$初始矩阵N来乘以M就可以了，初始矩阵N如下所示

$$
\begin{pmatrix}
     1      &     0 &      0 & \cdots &      0  
\end{pmatrix}
$$

这个矩阵只有1行，每一个元素都对应处于一种状态的概率。初始矩阵第一个元素为1,其余为0，代表在开始投掷硬币之间，处于状态0的概率是100%。容易知道$$N \times M$$的结果如下

$$
\begin{pmatrix}
     1/2     &     1/2 &      0 & \cdots &      0  
\end{pmatrix}
$$

这表示经过一次投掷之后，状态0和1的概率是1/2。于是问题就简单了，投掷m次硬币的话，只要乘以矩阵M m次就可以获得m次之后的最终状态概率分布。不过我们的问题是求m次投掷之中有至少n次连续正面的概率而不是，m次投掷结束时有n次连续正面的概率分布。这个问题非常好解决，其实意思就是一旦进入状态n，那么就不再进入其他状态了。因此我们只需要修改一下矩阵M将其变为$$(n+1) \times （n+1）$$阶就可以了。

这里我们同样设m=10,n=4同时给出一个R代码示例

{% highlight python linenos %}
matrix_m = matrix(0, 5, 5)
matrix_m[1:4] = 0.5
matrix_m[seq(6,25,6)] = 0.5
matrix_m[5^2] = 1
matrix_m

#       [,1] [,2] [,3] [,4] [,5]
# [1,]  0.5  0.5  0.0  0.0  0.0
# [2,]  0.5  0.0  0.5  0.0  0.0
# [3,]  0.5  0.0  0.0  0.5  0.0
# [4,]  0.5  0.0  0.0  0.0  0.5
# [5,]  0.0  0.0  0.0  0.0  1.0

matrix_n = rep(0, 5)
matrix_n[1] = 1

matrix_n
# [1] 1 0 0 0 0

for(iter in 1:10){
  matrix_n = matrix_n %*% matrix_m
}

matrix_n
#           [,1]      [,2]      [,3]       [,4]      [,5]
# [1,] 0.3774414 0.1958008 0.1015625 0.05273438 0.2724609

{% endhighlight %}

最后那个0.272就是10次硬币投掷中出现至少4次连续正面的概率。故事到此还没结束，使用马尔可夫链还可以计算更复杂的情况。比如10次硬币投掷中，至少出现3次连续2次正面的概率，其中连续3次正面不能视为两次，连续4次正面可被视为两次。

这个问题只要你构建下面的状态转换矩阵就可以了

$$
\begin{pmatrix}
     1/2 & 1/2 &   0 &   0 &   0 &   0 &   0 \\
     1/2 &   0 & 1/2 &   0 &   0 &   0 &   0 \\
       0 &   0 & 1/2 & 1/2 &   0 &   0 &   0 \\
       0 &   0 & 1/2 &   0 & 1/2 &   0 &   0 \\
       0 &   0 &   0 &   0 & 1/2 & 1/2 &   0 \\
       0 &   0 &   0 &   0 & 1/2 &   0 & 1/2 \\
       0 &   0 &   0 &   0 &   0 &   0 &   1 \\
\end{pmatrix}
$$

另外关于矩阵的高次运算也顺便提一下，具体的原理就不展开讲了。上面的R代码中，10次投掷我们是通过乘以10次矩阵M来完成，如果m值变大，反复进行矩阵乘法的开销也不小。因此可以通过把矩阵对角化的方法来进行简化

$$
\begin{align}
  & M^m \\
= & (Q \times F \times Q^{-1})^m \\
= & Q \times F^m \times Q^{-1} \\
\end{align}
$$

{% highlight python linenos %}
matrix_m = matrix(0, 5, 5)
matrix_m[1:4] = 0.5
matrix_m[seq(6,25,6)] = 0.5
matrix_m[5^2] = 1
matrix_m

matrix_m_dco = eigen(matrix_m)
matrix_m_dco$vectors %*% diag(matrix_m_dco$values)^10 %*% solve(matrix_m_dco$vector)
{% endhighlight %}
