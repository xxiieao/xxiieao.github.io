<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Chorus</title>
    <description>这里主要是我学习的笔记，以及一些杂谈</description>
    <link>http://xxiieao.github.io/</link>
    <atom:link href="http://xxiieao.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 06 Nov 2015 18:45:45 +0800</pubDate>
    <lastBuildDate>Fri, 06 Nov 2015 18:45:45 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Principal of Aprirori</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#overview&quot; id=&quot;markdown-toc-overview&quot;&gt;Overview&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#base-theory-of-apriori&quot; id=&quot;markdown-toc-base-theory-of-apriori&quot;&gt;Base Theory of Apriori&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#steps-of-apriori&quot; id=&quot;markdown-toc-steps-of-apriori&quot;&gt;Steps of Apriori&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#step-1&quot; id=&quot;markdown-toc-step-1&quot;&gt;Step 1&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#step-2&quot; id=&quot;markdown-toc-step-2&quot;&gt;Step 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;overview&quot;&gt;Overview&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;DataMining&lt;/li&gt;
  &lt;li&gt;Frequent item-set&lt;/li&gt;
  &lt;li&gt;Bottom up approach&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;base-theory-of-apriori&quot;&gt;Base Theory of Apriori&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;If one item-set is &lt;em&gt;FREQUENT&lt;/em&gt;, all of its subsets are &lt;em&gt;FREQUENT&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;If an item-set is &lt;em&gt;INFREQUENT&lt;/em&gt;, none of the item-sets contains it would be &lt;em&gt;Frequent&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;steps-of-apriori&quot;&gt;Steps of Apriori&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;step1 counting and filtering candidate&lt;/li&gt;
  &lt;li&gt;step2 candidate generation&lt;/li&gt;
  &lt;li&gt;step3 return to step1, unless no or only one candidate left&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;step-1&quot;&gt;Step 1&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;order_id&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;item_name&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;b&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;c&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;b&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;e&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;f&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;counting&lt;/p&gt;

  &lt;p&gt;b: 2, c: 1, e: 1, f: 1&lt;/p&gt;

  &lt;p&gt;filted result&lt;/p&gt;

  &lt;p&gt;b: 2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;step-2&quot;&gt;Step 2&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;Single item scenario&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;items from step 1&lt;/p&gt;

  &lt;p&gt;a: 10, b: 5, c: 8, e: 7&lt;/p&gt;

  &lt;p&gt;generate candidate from a, b, c, e&lt;/p&gt;

  &lt;p&gt;[ab, ac, ae, bc, be, ce]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Multi item scenario&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;items from step 1&lt;/p&gt;

  &lt;p&gt;abc: 4, abd: 5, acd: 3&lt;/p&gt;

  &lt;p&gt;generate candidate from abc, acd, ace&lt;/p&gt;

  &lt;p&gt;[acde]&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 26 Oct 2015 04:16:22 +0800</pubDate>
        <link>http://xxiieao.github.io/2015/10/26/Principal-of-Apriori/</link>
        <guid isPermaLink="true">http://xxiieao.github.io/2015/10/26/Principal-of-Apriori/</guid>
        
        
        <category>algorithm</category>
        
      </item>
    
      <item>
        <title>Welcome to xxiieao</title>
        <description>&lt;p&gt;值得纪念的第一步&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Oct 2015 03:16:22 +0800</pubDate>
        <link>http://xxiieao.github.io/2015/10/26/Welcome-to-xxiieao/</link>
        <guid isPermaLink="true">http://xxiieao.github.io/2015/10/26/Welcome-to-xxiieao/</guid>
        
        
        <category>other</category>
        
      </item>
    
      <item>
        <title>How to Draw Fractal</title>
        <description>&lt;p&gt;先介绍一下分形吧。百度上面关于分形的定义比较罗嗦，其实分形最重要的特征就是自相似，说白了就是局部放大之后会和整体非常相似。以前在网上看到过许多分形的图片，觉得非常漂亮，但是也一直没有动手画过。昨天看了一些关于分形生长的论文，里面提到反复迭代函数&lt;script type=&quot;math/tex&quot;&gt;f(z) = z^2 + c&lt;/script&gt;就可以画出各种各样的分形。这个方程如此简单，让我觉得可以很轻松地在R中实现。不过很快我就犯了错误，看到论文的论述我的第一反应是&lt;script type=&quot;math/tex&quot;&gt;f(z)&lt;/script&gt;的轨迹图是个分形。不过R上实践的结果根本不是分形。于是到matrix67的博客上看到了关于如何使用&lt;script type=&quot;math/tex&quot;&gt;f(z) = z^2 + c&lt;/script&gt;画分形的解释。&lt;/p&gt;

&lt;p&gt;首先需要明确的第一点变量&lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt;是复数，当然&lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt;也是复数。&lt;/p&gt;

&lt;p&gt;其次构成分形的不是函数&lt;script type=&quot;math/tex&quot;&gt;f(z) = z^2 + c&lt;/script&gt;的轨迹，而是&lt;script type=&quot;math/tex&quot;&gt;f(z)&lt;/script&gt;的发散速度。&lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt;是不同数值时，即初始自变量不同&lt;script type=&quot;math/tex&quot;&gt;f(z)&lt;/script&gt;发散的速度是不同的。而在计算模拟中，为了方便处理，一般定义为超过某个阈值需要的迭代计算次数。例如当&lt;script type=&quot;math/tex&quot;&gt;z = 0.6 + 0.5i&lt;/script&gt;，&lt;script type=&quot;math/tex&quot;&gt;c = 1 + 0.5i&lt;/script&gt;时，阈值为2时，需要迭代两次，那么这个2就作为&lt;script type=&quot;math/tex&quot;&gt;x = 0.6&lt;/script&gt;和&lt;script type=&quot;math/tex&quot;&gt;y =0.5&lt;/script&gt;这个点发散速度。对某个区域的点均进行计算再根据迭代次数进行计算就可以得到一张分形图。下面是R的代码，有兴趣的同学可以试一下&lt;/p&gt;

&lt;p&gt;下面是当&lt;script type=&quot;math/tex&quot;&gt;c = 0.45 - 0.1428i&lt;/script&gt;时画出来的图片&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/6daafd01gw1exia8nn971j20ad09c74e.jpg&quot; alt=&quot;picture&quot; /&gt;
&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/6daafd01gw1exia8o83rnj20ad09c3ym.jpg&quot; alt=&quot;picture&quot; /&gt;
&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/6daafd01gw1exia8osu7cj20ad09caa5.jpg&quot; alt=&quot;picture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面附上R的代码&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-r&quot; data-lang=&quot;r&quot;&gt;&lt;span class=&quot;lineno&quot;&gt; 1&lt;/span&gt; complex_matrix_int &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;interval&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; x_start&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; x_end&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; y_start&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; y_end&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 2&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;#输入间隔，x轴和y轴的起始坐标&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 3&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;#输出一个由x坐标和y坐标构成的复数矩阵&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 4&lt;/span&gt;   x_distance &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; x_end &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; x_start
&lt;span class=&quot;lineno&quot;&gt; 5&lt;/span&gt;   y_distance &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; y_end &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; y_start
&lt;span class=&quot;lineno&quot;&gt; 6&lt;/span&gt;   xaxis &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;x_start&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; x_end&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; interval&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 7&lt;/span&gt;   yaxis &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;y_start&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; y_end&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; interval&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 8&lt;/span&gt;   x_rep_times &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;yaxis&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt; 9&lt;/span&gt;   y_rep_times &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;xaxis&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;10&lt;/span&gt;   &lt;span class=&quot;kt&quot;&gt;matrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;complex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;real &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;rep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;xaxis&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; x_rep_times&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;11&lt;/span&gt;                  imaginary &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;rep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;yaxis&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; each &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; y_rep_times&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;12&lt;/span&gt;                  x_rep_times&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; y_rep_times&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; byrow &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;13&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;14&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;15&lt;/span&gt; iterator &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;complex_matrix&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; constant&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;16&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;#输入一个由x坐标和y坐标构成的复数矩阵和常数c&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;17&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;#输出一个与输入对应的矩阵，每个元素代表对应坐标超过2时的迭代次数&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;18&lt;/span&gt;   res &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;matrix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;nrow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;complex_matrix&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;ncol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;complex_matrix&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;19&lt;/span&gt;   &lt;span class=&quot;kr&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;i &lt;span class=&quot;kr&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#因为有的点是收敛而非发散永远不会超过2因此设置迭代上限为100次&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;20&lt;/span&gt;     res &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; res &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;as.numeric&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;abs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;complex_matrix&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;21&lt;/span&gt;     complex_matrix &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; complex_matrix&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; constant
&lt;span class=&quot;lineno&quot;&gt;22&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;23&lt;/span&gt;   res
&lt;span class=&quot;lineno&quot;&gt;24&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;25&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;26&lt;/span&gt; fractal_plot &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;interval &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.005&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;27&lt;/span&gt;                         x_start &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;-1.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; x_end &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;28&lt;/span&gt;                         y_start &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;-1.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; y_end &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;29&lt;/span&gt;                         constant &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.45-0.1428i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;30&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;#调用complex_matrix_int和iterator&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;31&lt;/span&gt;   complex_matrix &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; complex_matrix_int&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;interval&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; x_start&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; x_end&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; y_start&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; y_end&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;32&lt;/span&gt;   iter_times_matrix &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; iterator&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;complex_matrix&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; constant&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;33&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;#并对迭代次数的矩阵进行染色&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;34&lt;/span&gt;   filled.contour&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;x_start&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; x_end&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; interval&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;35&lt;/span&gt;                  y &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;seq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;y_start&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; y_end&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; interval&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;36&lt;/span&gt;                  z &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;iter_times_matrix&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;37&lt;/span&gt;                  col &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; rainbow&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;121&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;38&lt;/span&gt;                  levels &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kp&quot;&gt;pretty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;101&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;39&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;40&lt;/span&gt; 
&lt;span class=&quot;lineno&quot;&gt;41&lt;/span&gt; fractal_plot&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0.005&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;-1.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;-1.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.45-0.1428i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#第一张图&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;42&lt;/span&gt; fractal_plot&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0.001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;-0.6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;-0.1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.45-0.1428i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#第二张图&lt;/span&gt;
&lt;span class=&quot;lineno&quot;&gt;43&lt;/span&gt; fractal_plot&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0.00025&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;-0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;-0.4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.45-0.1428i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;#第三张图&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 06 Apr 2015 05:10:02 +0800</pubDate>
        <link>http://xxiieao.github.io/2015/04/06/How-to-Draw-Fractal/</link>
        <guid isPermaLink="true">http://xxiieao.github.io/2015/04/06/How-to-Draw-Fractal/</guid>
        
        
        <category>math</category>
        
      </item>
    
      <item>
        <title>ID3</title>
        <description>&lt;p&gt;决策树是数据挖掘中非常重要的组成部分，不过它并不属于机器学习的范畴。这里面的原因和主导决策数的基本思想——贪心算法有关系，在每一次分类都稳稳当当地走出最好一部的指导思想下，当然不需要学习。&lt;/p&gt;

&lt;p&gt;话题有点远，决策树最典型的算法代表有三种ID3，C4.5，CART。其中ID3和C4.5都是基于信息熵计算的，而CART是基于Gini指数计算的。C4.5是ID3的改良算法，能处理连续变量也就是能分类也能回归，而ID3只能处理分类变量。&lt;/p&gt;

&lt;p&gt;这次我们先看看简单的ID3是如何工作的。开始前我们先回忆一下信息熵的意义——熵值越大信息越不确定。然后假设商店拥有以下数据，用户性别、手机系统类型和购买记录。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;ID&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;sex&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;mobile_os&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;purchase_record&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;male&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;android&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;no&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;male&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ios&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;male&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ios&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;male&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;android&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;no&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;male&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;android&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;no&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;female&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;android&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;no&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;female&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ios&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;female&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ios&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;female&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ios&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;female&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;android&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;然后希望按照这些数据构造一棵回归树来分类用户购买行为，首先需要解决的问题是sex和mobilebile_os谁来当根结点。&lt;/p&gt;

&lt;p&gt;先来看购买数据purchase_record本身的熵值，yes有6条记录，no有4条&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;H_{purchase}=-0.6*log_2{0.6}-0.4*log_2{0.4}=0.971&lt;/script&gt;

&lt;p&gt;然后再来看sex分类下male这个小组purchase_record的熵值{即sex=male条件下purchase_record的条件熵}，yes记录2条，no有3条&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;H_{purchase|sex=male}=-0.4*log_2{0.4}-0.6*log_2{0.6}=0.971&lt;/script&gt;

&lt;p&gt;同样分类female下purchase_record的条件熵值&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;H_{purchase|sex=female}=-0.8*log_2{0.8}-0.2*log2{0.2}=0.722&lt;/script&gt;

&lt;p&gt;那么purchase_record关于sex的条件熵就等于male和female各自的概率乘以条件熵之和。&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;H_{purchase|sex}=0.5*0.971+0.5*0.722=0.846&lt;/script&gt;

&lt;p&gt;同样可以算得&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;H_{purchase|mobile\_os}=0.722*0.5+0*0.5=0.361&lt;/script&gt;

&lt;p&gt;显然在第一步分类中，mobile_os这一数据让purchase_record变得更有顺序了。在ID3的实际应用中，使用的是信息增益。在上面的例子，sex的信息增益度为&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;H_{purchase}-H_{purchase|sex}=0.971-0.846=0.025&lt;/script&gt;

&lt;p&gt;而mobiles_os=0.610。&lt;/p&gt;

&lt;p&gt;那么我们可以决定第一个分类变量选择的就是mobile_os。第二次分类的变量用同样的方法决定，不过在例子中由于只有两个变量，可以想象我们可以得到如下分类树。&lt;/p&gt;

&lt;script src=&quot;http://cdn.bootcss.com/mermaid/0.5.4/mermaid.js&quot;&gt;&lt;/script&gt;

&lt;div class=&quot;mermaid&quot;&gt;
graph TD;
    start(user)--&amp;gt;mobile_os{ios?};
    mobile_os--&amp;gt; |yes| result1[purchase=yes];
    mobile_os--&amp;gt; |no| sex{male?};
    sex--&amp;gt; |yes| result2[purchase=no];
    sex--&amp;gt; |no| result3[50%purchase=no,50%purchase=yes];
&lt;/div&gt;

&lt;p&gt;第一个mobile_os=ios的分支之所以没再继续按sex分类是因为该组的purchase都是yes，熵值为0没有必要再分。在实际应用中为了防止过度分类，常常会设定增益度阈值，低于该阈值则不再划分。&lt;/p&gt;
</description>
        <pubDate>Sun, 21 Sep 2014 19:45:22 +0800</pubDate>
        <link>http://xxiieao.github.io/2014/09/21/ID3/</link>
        <guid isPermaLink="true">http://xxiieao.github.io/2014/09/21/ID3/</guid>
        
        
        <category>algorithm</category>
        
      </item>
    
      <item>
        <title>SVM</title>
        <description>&lt;p&gt;SVM，全称support vector machine中文名字叫支持向量机。我刚接触时觉得很高大上，感觉和图灵机、冯诺依曼机一样。我接触SVM的时间非常短，在很长一段时间内只是知道有这样东西的存在，而对SVM的了解就仅限于百度百科里有一段资料——“支持向量机将向量映射到一个更高维的空间里，在这个空间里建立有一个最大间隔超平面。在分开数据的超平面的两边建有两个互相平行的超平面。”我对于这个描述完全是高大上和不明觉厉的节奏。实际上此机并非彼机，虽然名字中有个“机”字，但是支持向量机只是一种最优化算法，本质上和梯度下降算法、遗传算法等等是没有区别的。当SVM同样也属于机器学习的范畴。下面我们就走进科学看看SVM的本质。&lt;/p&gt;

&lt;p&gt;首先来看看SVM能做什么？一句话概之，普通监督分类算法能做的，它也能做。&lt;/p&gt;

&lt;p&gt;那么普通监督分类算法能做的，为何要用SVM来做？同样一句话回答，因为它做得更好。这里我们用两张图来表示什么叫做更好：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/6daafd01gw1exrfoaasncj208b06jmxh.jpg&quot; alt=&quot;picture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图1是普通监督分类算法可能会得出的结果，我们可以发现以现有数据来说，这条直线都很好进行了分类。这是因为在梯度下降的过程中，当两类数据被完全分开后，代价函数就不会再移动了，所以直线也就不会再移动了。显然这条直线并不是我们最想要的结果，SVM就能克服这个问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/6daafd01gw1exrfoapgorj208k06jwex.jpg&quot; alt=&quot;picture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图2所示SVM会把边界划分在距离两类数据距离最大的地方，因此有时候SVM也被称为大边际分类器（large margin classifier），不过这个名字已经暴露了SVM一部分的本质。&lt;/p&gt;

&lt;p&gt;最后一个问题，为何SVM能分在这个地方？为啥SVM的名字里有向量一词？先看下面图3，抛开SVM里面复杂的核函数什么的，先看两条边界线，左边一条是普通监督分类算法的结果，右边一条是SVM的结果。先将边界线的参数作为向量（绿虚线）画出来（这个向量是与边界线垂直的，例如左边的边界线是&lt;script type=&quot;math/tex&quot;&gt;X_1-X_2=0&lt;/script&gt;，边界线参数&lt;script type=&quot;math/tex&quot;&gt;X_1&lt;/script&gt;和&lt;script type=&quot;math/tex&quot;&gt;X_2&lt;/script&gt;的系数即[1,1]，而右边的边界线是&lt;script type=&quot;math/tex&quot;&gt;0*X_1+X_2=0&lt;/script&gt;即[1,0]）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/6daafd01gw1exrfoazhtnj20h606c3yz.jpg&quot; alt=&quot;picture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在讨论SVM的神奇效果之前，先说明一下如何利用边界线进行区分红蓝点。例如在左图R1有两个坐标[&lt;script type=&quot;math/tex&quot;&gt;X_1R_1&lt;/script&gt;,&lt;script type=&quot;math/tex&quot;&gt;X_2R_1&lt;/script&gt;]，那么他的预测值&lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt;就等于[&lt;script type=&quot;math/tex&quot;&gt;X_1R_1&lt;/script&gt;,&lt;script type=&quot;math/tex&quot;&gt;X_2R_1&lt;/script&gt;]对边界线的参数[1,1]做点乘法再求和，而这个过程实际上等于R1点在绿虚线上的投影（红实线）长度乘以绿虚线本身的长度。这其实就是向量乘积的变换过程，也是SVM里向量一词的由来。&lt;/p&gt;

&lt;p&gt;总结上面一点其实就是说红蓝点的区分是以每个点在边界线的垂直线上的投影长度与边界线参数向量的长度的乘积（即&lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt;）来决定的。相对与普通的监督分类算法，SVM做了一个要求边界线参数向量长度要尽量短。可以想到对于同样的Y值来说，其实就是要求各点投影长度的总和要尽量长（例如&lt;script type=&quot;math/tex&quot;&gt;R_1&lt;/script&gt;点在左图的投影显然短于右图的投影，左图边界线参数向量的长度为&lt;script type=&quot;math/tex&quot;&gt;sqrt(2)&lt;/script&gt;，而右图边界线参数向量的长度仅为1）。&lt;/p&gt;
</description>
        <pubDate>Sun, 24 Aug 2014 21:03:35 +0800</pubDate>
        <link>http://xxiieao.github.io/2014/08/24/SVM/</link>
        <guid isPermaLink="true">http://xxiieao.github.io/2014/08/24/SVM/</guid>
        
        
        <category>algorithm</category>
        
      </item>
    
  </channel>
</rss>
